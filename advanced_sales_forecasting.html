<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Îß§Ï∂ú ÏòàÏ∏° ÏãúÎÆ¨Î†àÏù¥ÌÑ∞ Pro</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Ï†ÑÏ≤¥ Ïä§ÌÉÄÏùºÎßÅ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #1a1a1a;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .app-container {
            min-height: 100vh;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem;
            background: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%);
            border-radius: 1rem;
            color: white;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        .grid {
            display: grid;
            gap: 1.5rem;
            grid-template-columns: 1fr 2fr;
        }

        @media (max-width: 1024px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        /* Ïπ¥Îìú Ïä§ÌÉÄÏùº */
        .card {
            background: white;
            border-radius: 1rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #f1f5f9;
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e293b;
        }

        /* Ìèº ÏöîÏÜå */
        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #374151;
            font-size: 0.875rem;
        }

        .form-input, .form-select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            background: white;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #4F46E5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #e5e7eb, #4F46E5);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            transition: all 0.2s ease;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4F46E5;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(79, 70, 229, 0.3);
            transition: all 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.4);
        }

        /* Î≤ÑÌäº */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .btn-secondary {
            background: #f8fafc;
            color: #475569;
            border: 1px solid #e2e8f0;
        }

        .btn-secondary:hover {
            background: #f1f5f9;
            transform: translateY(-1px);
        }

        .btn-reset {
            background: #fef3c7;
            color: #d97706;
            border: 1px solid #fbbf24;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
        }

        .btn-reset:hover {
            background: #fde68a;
        }

        /* Ï∞®Ìä∏ */
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
            background: white;
            border-radius: 0.75rem;
            padding: 1rem;
        }

        /* ÌÖåÏù¥Î∏î */
        .table-container {
            overflow-x: auto;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        .table th {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
        }

        .table td {
            padding: 0.75rem;
            border-bottom: 1px solid #f1f5f9;
        }

        .table tr:hover {
            background: #f8fafc;
        }

        /* ÌÜµÍ≥Ñ Ïπ¥Îìú */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
            padding: 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid #e2e8f0;
            text-align: center;
        }

        .stat-value {
            font-size: 1.875rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .stat-label {
            font-size: 0.875rem;
            color: #64748b;
        }

        /* Î°úÎî© Ïï†ÎãàÎ©îÏù¥ÏÖò */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #f1f5f9;
            border-top: 3px solid #4F46E5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ÏïåÍ≥†Î¶¨Ï¶ò Î±ÉÏßÄ */
        .algorithm-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }

        .badge-basic {
            background: #dbeafe;
            color: #1d4ed8;
        }

        .badge-advanced {
            background: #f3e8ff;
            color: #7c3aed;
        }

        .badge-expert {
            background: #fef3c7;
            color: #d97706;
        }

        .badge-ai {
            background: #10b981;
            color: white;
        }

        /* ÌååÎùºÎ©îÌÑ∞ Ï°∞Ï†ï ÏòÅÏó≠ */
        .parameter-section {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            padding: 1rem;
            border-radius: 0.75rem;
            margin-top: 1rem;
            border: 1px solid #e2e8f0;
        }

        .parameter-grid {
            display: grid;
            gap: 1rem;
            margin-top: 1rem;
        }

        .parameter-item {
            background: white;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }

        .parameter-label {
            font-weight: 500;
            font-size: 0.875rem;
            color: #374151;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .parameter-value {
            color: #4F46E5;
            font-weight: 600;
        }

        .parameter-description {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        .algorithm-description {
            background: linear-gradient(135deg, #eff6ff 0%, #f0f9ff 100%);
            padding: 1rem;
            border-radius: 0.75rem;
            border-left: 4px solid #3b82f6;
            margin-top: 1rem;
        }

        /* Ïú†Ìã∏Î¶¨Ìã∞ */
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        .font-bold { font-weight: 700; }
        .font-medium { font-weight: 500; }
        .text-sm { font-size: 0.875rem; }
        .text-xs { font-size: 0.75rem; }
        .text-gray-600 { color: #4b5563; }
        .text-gray-500 { color: #6b7280; }
        .text-green-600 { color: #16a34a; }
        .text-red-600 { color: #dc2626; }
        .text-blue-600 { color: #2563eb; }
        .text-purple-600 { color: #9333ea; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mt-4 { margin-top: 1rem; }
        .space-y-4 > * + * { margin-top: 1rem; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .gap-2 { gap: 0.5rem; }
        .gap-4 { gap: 1rem; }

        /* Î∞òÏùëÌòï */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.875rem;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-container {
                height: 300px;
            }
        }

        /* ÌÜ†Ïä§Ìä∏ ÏïåÎ¶º */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            border-left: 4px solid #10b981;
        }

        .toast.error {
            border-left: 4px solid #ef4444;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef, useCallback } = React;

        // üéØ ÌÜ†Ïä§Ìä∏ ÏïåÎ¶º Ïª¥Ìè¨ÎÑåÌä∏
        const Toast = ({ message, type, show, onClose }) => {
            useEffect(() => {
                if (show) {
                    const timer = setTimeout(() => {
                        onClose();
                    }, 3000);
                    return () => clearTimeout(timer);
                }
            }, [show, onClose]);

            return (
                <div className={`toast ${type} ${show ? 'show' : ''}`}>
                    <div className="flex items-center gap-2">
                        <i className={`fas ${type === 'success' ? 'fa-check-circle text-green-600' : 'fa-exclamation-triangle text-red-600'}`}></i>
                        <span>{message}</span>
                    </div>
                </div>
            );
        };

        // üéØ Î°úÎî© Ïª¥Ìè¨ÎÑåÌä∏
        const LoadingSpinner = ({ message = "Î∂ÑÏÑù Ï§ë..." }) => (
            <div className="loading">
                <div className="flex items-center gap-4">
                    <div className="spinner"></div>
                    <span className="text-gray-600">{message}</span>
                </div>
            </div>
        );

        // üéØ ÌååÎùºÎ©îÌÑ∞ Ï°∞Ï†ï Ïª¥Ìè¨ÎÑåÌä∏
        const ParameterControl = ({ label, value, min, max, step, onChange, description, suffix = "" }) => (
            <div className="parameter-item">
                <div className="parameter-label">
                    <span>{label}</span>
                    <span className="parameter-value">{value}{suffix}</span>
                </div>
                <input
                    type="range"
                    min={min}
                    max={max}
                    step={step}
                    value={value}
                    onChange={(e) => onChange(parseFloat(e.target.value))}
                    className="slider"
                />
                {description && (
                    <div className="parameter-description">
                        {description}
                    </div>
                )}
            </div>
        );

        // üéØ Ï∞®Ìä∏ Ïª¥Ìè¨ÎÑåÌä∏
        const SalesChart = ({ data, predictions, showConfidenceInterval = true, isLoading = false }) => {
            const chartRef = useRef(null);
            const chartInstanceRef = useRef(null);

            useEffect(() => {
                if (!chartRef.current || isLoading) return;

                const ctx = chartRef.current.getContext('2d');
                
                if (chartInstanceRef.current) {
                    chartInstanceRef.current.destroy();
                }

                const allData = [...data, ...predictions];
                const labels = allData.map(d => d.date);
                const actualData = allData.map(d => d.type === 'predicted' ? null : d.sales);
                const predictedData = allData.map(d => d.type === 'predicted' ? d.sales : null);

                const datasets = [
                    {
                        label: 'Ïã§Ï†ú Îß§Ï∂ú',
                        data: actualData,
                        borderColor: '#4F46E5',
                        backgroundColor: 'rgba(79, 70, 229, 0.1)',
                        fill: false,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        borderWidth: 3
                    },
                    {
                        label: 'ÏòàÏ∏° Îß§Ï∂ú',
                        data: predictedData,
                        borderColor: '#EF4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        fill: false,
                        tension: 0.4,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        borderDash: [10, 5],
                        borderWidth: 3
                    }
                ];

                if (showConfidenceInterval && predictions.length > 0) {
                    const upperBoundData = allData.map(d => {
                        if (d.type === 'predicted') {
                            return d.sales * 1.15;
                        }
                        return null;
                    });
                    const lowerBoundData = allData.map(d => {
                        if (d.type === 'predicted') {
                            return d.sales * 0.85;
                        }
                        return null;
                    });

                    datasets.push(
                        {
                            label: '95% Ïã†Î¢∞Íµ¨Í∞Ñ',
                            data: upperBoundData,
                            borderColor: 'rgba(239, 68, 68, 0.3)',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            fill: '+1',
                            tension: 0.4,
                            pointRadius: 0,
                            borderDash: [5, 5],
                            borderWidth: 1
                        },
                        {
                            label: '',
                            data: lowerBoundData,
                            borderColor: 'rgba(239, 68, 68, 0.3)',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0,
                            borderDash: [5, 5],
                            borderWidth: 1
                        }
                    );
                }

                chartInstanceRef.current = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Îß§Ï∂ú Ï∂îÏù¥ Î∞è ÏòàÏ∏° Î∂ÑÏÑù',
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                },
                                padding: 20
                            },
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    padding: 20,
                                    usePointStyle: true
                                }
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'ÎÇ†Ïßú',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Îß§Ï∂ú (ÎßåÏõê)',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                },
                                beginAtZero: false
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        }
                    }
                });

                return () => {
                    if (chartInstanceRef.current) {
                        chartInstanceRef.current.destroy();
                    }
                };
            }, [data, predictions, showConfidenceInterval, isLoading]);

            if (isLoading) {
                return <LoadingSpinner message="Ï∞®Ìä∏ ÏÉùÏÑ± Ï§ë..." />;
            }

            return <canvas ref={chartRef} />;
        };

        // üöÄ Î©îÏù∏ Ïï± Ïª¥Ìè¨ÎÑåÌä∏
        const AdvancedSalesForecastingApp = () => {
            // ÏÉÅÌÉú Í¥ÄÎ¶¨
            const [historicalData, setHistoricalData] = useState([]);
            const [selectedAlgorithm, setSelectedAlgorithm] = useState('advanced_ensemble');
            const [selectedCountry, setSelectedCountry] = useState('Ï†ÑÏ≤¥');
            const [selectedProduct, setSelectedProduct] = useState('Ï†ÑÏ≤¥');
            const [isLoading, setIsLoading] = useState(false);
            const [showConfidenceInterval, setShowConfidenceInterval] = useState(true);
            const [toast, setToast] = useState({ show: false, message: '', type: 'success' });
            const [forecastPeriod, setForecastPeriod] = useState(12);

            // üéØ ÌååÎùºÎ©îÌÑ∞ ÏÉÅÌÉú Í¥ÄÎ¶¨
            const [algorithmParameters, setAlgorithmParameters] = useState({
                advanced_ensemble: {
                    trend_weight: 0.3,
                    seasonal_weight: 0.3,
                    ma_weight: 0.2,
                    exp_weight: 0.2,
                    forecast_length: 12
                },
                transformer_model: {
                    attention_heads: 8,
                    model_dim: 64,
                    learning_rate: 0.001,
                    sequence_length: 12,
                    forecast_length: 12
                },
                gru_network: {
                    hidden_size: 50,
                    sequence_length: 12,
                    learning_rate: 0.01,
                    dropout_rate: 0.2,
                    forecast_length: 12
                },
                wavelet_arima: {
                    decomp_levels: 3,
                    arima_p: 2,
                    arima_d: 1,
                    arima_q: 2
                },
                gradient_boosting: {
                    n_estimators: 100,
                    learning_rate: 0.1,
                    max_depth: 6,
                    subsample: 0.8,
                    forecast_length: 12
                },
                nbeats_model: {
                    num_blocks: 3,
                    stack_weight: 0.5,
                    forecast_length: 12, // adjustable between 12 and 24 months
                    backcast_length: 24
                }
            });

            // üéØ Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
            const defaultParameters = {
                advanced_ensemble: {
                    trend_weight: 0.3,
                    seasonal_weight: 0.3,
                    ma_weight: 0.2,
                    exp_weight: 0.2,
                    forecast_length: 12
                },
                transformer_model: {
                    attention_heads: 8,
                    model_dim: 64,
                    learning_rate: 0.001,
                    sequence_length: 12,
                    forecast_length: 12
                },
                gru_network: {
                    hidden_size: 50,
                    sequence_length: 12,
                    learning_rate: 0.01,
                    dropout_rate: 0.2,
                    forecast_length: 12
                },
                wavelet_arima: {
                    decomp_levels: 3,
                    arima_p: 2,
                    arima_d: 1,
                    arima_q: 2
                },
                gradient_boosting: {
                    n_estimators: 100,
                    learning_rate: 0.1,
                    max_depth: 6,
                    subsample: 0.8,
                    forecast_length: 12
                },
                nbeats_model: {
                    num_blocks: 3,
                    stack_weight: 0.5,
                    forecast_length: 12, // adjustable between 12 and 24 months
                    backcast_length: 24
                }
            };

            // ÏòàÏ∏° Í∏∞Í∞Ñ Î≥ÄÍ≤Ω Ïãú Í∞Å ÏïåÍ≥†Î¶¨Ï¶òÏùò forecast_length ÎèôÍ∏∞Ìôî
            useEffect(() => {
                setAlgorithmParameters(prev => ({
                    ...prev,
                    [selectedAlgorithm]: {
                        ...prev[selectedAlgorithm],
                        forecast_length: forecastPeriod
                    }
                }));
            }, [selectedAlgorithm, forecastPeriod]);

            // üéØ ÏÉòÌîå Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
            const generateSampleData = useCallback(() => {
                const data = [];
                const countries = ['ÌïúÍµ≠', 'ÎØ∏Íµ≠', 'ÏùºÎ≥∏', 'Ï§ëÍµ≠', 'ÎèÖÏùº'];
                const products = ['Ï†úÌíàA', 'Ï†úÌíàB', 'Ï†úÌíàC', 'Ï†úÌíàD'];
                
                for (let year = 2019; year <= 2024; year++) {
                    for (let month = 1; month <= 12; month++) {
                        countries.forEach(country => {
                            products.forEach(product => {
                                const baseSales = {
                                    'ÌïúÍµ≠': {'Ï†úÌíàA': 120, 'Ï†úÌíàB': 95, 'Ï†úÌíàC': 75, 'Ï†úÌíàD': 60},
                                    'ÎØ∏Íµ≠': {'Ï†úÌíàA': 200, 'Ï†úÌíàB': 170, 'Ï†úÌíàC': 140, 'Ï†úÌíàD': 110},
                                    'ÏùºÎ≥∏': {'Ï†úÌíàA': 100, 'Ï†úÌíàB': 85, 'Ï†úÌíàC': 65, 'Ï†úÌíàD': 50},
                                    'Ï§ëÍµ≠': {'Ï†úÌíàA': 180, 'Ï†úÌíàB': 150, 'Ï†úÌíàC': 120, 'Ï†úÌíàD': 90},
                                    'ÎèÖÏùº': {'Ï†úÌíàA': 90, 'Ï†úÌíàB': 75, 'Ï†úÌíàC': 60, 'Ï†úÌíàD': 45}
                                }[country][product];
                                
                                const yearGrowth = (year - 2019) * 0.08;
                                const seasonalFactor = 1 + 0.15 * Math.sin((month - 1) / 12 * 2 * Math.PI + Math.PI/6);
                                const randomFactor = 0.85 + Math.random() * 0.3;
                                
                                const sales = Math.round(baseSales * (1 + yearGrowth) * seasonalFactor * randomFactor);
                                
                                data.push({
                                    year,
                                    month,
                                    country,
                                    product,
                                    sales,
                                    date: `${year}-${month.toString().padStart(2, '0')}`
                                });
                            });
                        });
                    }
                }
                return data;
            }, []);

            // Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ ÏÑ§Ï†ï
            useEffect(() => {
                setHistoricalData(generateSampleData());
                showToast('ÏÉòÌîå Îç∞Ïù¥ÌÑ∞Í∞Ä Î°úÎìúÎêòÏóàÏäµÎãàÎã§!', 'success');
            }, [generateSampleData]);

            // üéØ ÌÜ†Ïä§Ìä∏ ÏïåÎ¶º ÌëúÏãú
            const showToast = useCallback((message, type = 'success') => {
                setToast({ show: true, message, type });
            }, []);

            const hideToast = useCallback(() => {
                setToast(prev => ({ ...prev, show: false }));
            }, []);

            // üéØ ÌååÎùºÎ©îÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
            const updateParameter = useCallback((algorithm, param, value) => {
                setAlgorithmParameters(prev => ({
                    ...prev,
                    [algorithm]: {
                        ...prev[algorithm],
                        [param]: value
                    }
                }));
            }, []);

            // üéØ ÌååÎùºÎ©îÌÑ∞ Î¶¨ÏÖã
            const resetParameters = useCallback(() => {
                setAlgorithmParameters(prev => ({
                    ...prev,
                    [selectedAlgorithm]: { ...defaultParameters[selectedAlgorithm] }
                }));
                showToast('ÌååÎùºÎ©îÌÑ∞Í∞Ä Í∏∞Î≥∏Í∞íÏúºÎ°ú Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§!', 'success');
            }, [selectedAlgorithm]);

            // üéØ Í≥†Í∏â ÏïåÍ≥†Î¶¨Ï¶òÎì§
            const algorithms = {
                // üöÄ Í≥†Í∏â ÏïôÏÉÅÎ∏î
                advanced_ensemble: (data, params) => {
                    if (data.length === 0) return [];

                    const predictions = [];
                    const weights = {
                        trend: params.trend_weight,
                        seasonal: params.seasonal_weight,
                        ma: params.ma_weight,
                        exp: params.exp_weight
                    };
                    const forecast_length = params.forecast_length;

                    // Îã§Ï§ë Î™®Îç∏ ÏòàÏ∏°
                    const trendPred = linearTrend(data, { growth_rate: 0.06, seasonal_factor: 0.12 }, forecast_length);
                    const seasonalPred = seasonalDecompose(data, { strength: 0.8 }, forecast_length);
                    const maPred = movingAverage(data, { window: 8, trend_adj: 0.04 }, forecast_length);
                    const expPred = exponentialSmoothing(data, { alpha: 0.4, beta: 0.3, gamma: 0.3 }, forecast_length);

                    for (let i = 0; i < forecast_length; i++) {
                        const ensembleValue =
                            (trendPred[i]?.sales || 0) * weights.trend +
                            (seasonalPred[i]?.sales || 0) * weights.seasonal +
                            (maPred[i]?.sales || 0) * weights.ma +
                            (expPred[i]?.sales || 0) * weights.exp;
                        
                        predictions.push({
                            year: 2025,
                            month: i + 1,
                            sales: Math.round(Math.max(0, ensembleValue)),
                            date: `2025-${(i + 1).toString().padStart(2, '0')}`,
                            type: 'predicted'
                        });
                    }
                    
                    return predictions;
                },

                // üöÄ Transformer Í∏∞Î∞ò ÏòàÏ∏°
                transformer_model: (data, params) => {
                    if (data.length < 24) return [];
                    
                    const { attention_heads, model_dim, learning_rate, sequence_length, forecast_length } = params;
                    const predictions = [];
                    
                    const sales = data.map(d => d.sales);
                    const normalized = normalizeData(sales);
                    const sequences = createSequences(normalized, sequence_length);
                    
                    // Self-Attention Î©îÏª§ÎãàÏ¶ò ÏãúÎÆ¨Î†àÏù¥ÏÖò
                    const attention_weights = calculateAttentionWeights(sequences, attention_heads, forecast_length);
                    
                    for (let i = 1; i <= forecast_length; i++) {
                        const context_vector = applyAttention(sequences.slice(-sequence_length), attention_weights, forecast_length);
                        const base_prediction = context_vector.reduce((sum, val, idx) => sum + val * (1 - idx * learning_rate), 0);
                        
                        const seasonal_factor = 1 + 0.15 * Math.sin((i - 1) / 12 * 2 * Math.PI + Math.PI/4);
                        const forecast = denormalizeData(base_prediction * seasonal_factor, sales);
                        
                        predictions.push({
                            year: 2025,
                            month: i,
                            sales: Math.round(Math.max(0, forecast)),
                            date: `2025-${i.toString().padStart(2, '0')}`,
                            type: 'predicted'
                        });
                    }
                    
                    return predictions;
                },

                // üöÄ GRU Ïã†Í≤ΩÎßù
                gru_network: (data, params) => {
                    if (data.length < 24) return [];
                    
                    const { hidden_size, sequence_length, learning_rate, dropout_rate, forecast_length } = params;
                    const predictions = [];
                    
                    const sales = data.map(d => d.sales);
                    const normalized = normalizeData(sales);
                    
                    let hidden_state = Array(hidden_size).fill(0);
                    
                    for (let t = 0; t < Math.min(sequence_length, normalized.length); t++) {
                        hidden_state = gruCell(normalized[normalized.length - sequence_length + t], hidden_state, dropout_rate);
                    }
                    
                    for (let i = 1; i <= forecast_length; i++) {
                        const prediction = gruPredict(hidden_state, i, learning_rate);
                        const denorm_pred = denormalizeData(prediction, sales);
                        
                        const trend_factor = 1 + 0.05 * i / 12;
                        const seasonal_factor = 1 + 0.12 * Math.sin((i - 1) / 12 * 2 * Math.PI + Math.PI/3);
                        
                        predictions.push({
                            year: 2025,
                            month: i,
                            sales: Math.round(Math.max(0, denorm_pred * trend_factor * seasonal_factor)),
                            date: `2025-${i.toString().padStart(2, '0')}`,
                            type: 'predicted'
                        });
                    }
                    
                    return predictions;
                },

                // üöÄ Ïõ®Ïù¥Î∏îÎ¶ø + ARIMA
                wavelet_arima: (data, params) => {
                    if (data.length < 36) return [];
                    
                    const { decomp_levels, arima_p, arima_d, arima_q } = params;
                    const predictions = [];
                    
                    const sales = data.map(d => d.sales);
                    const decomposed = waveletDecompose(sales, decomp_levels);
                    const forecasts = decomposed.map(component => 
                        arimaForecast(component, [arima_p, arima_d, arima_q], 12)
                    );
                    
                    for (let i = 0; i < 12; i++) {
                        const reconstructed = waveletReconstruct(forecasts.map(f => f[i]));
                        
                        predictions.push({
                            year: 2025,
                            month: i + 1,
                            sales: Math.round(Math.max(0, reconstructed)),
                            date: `2025-${(i + 1).toString().padStart(2, '0')}`,
                            type: 'predicted'
                        });
                    }
                    
                    return predictions;
                },

                // üöÄ Í∑∏ÎùºÎîîÏñ∏Ìä∏ Î∂ÄÏä§ÌåÖ
                gradient_boosting: (data, params, forecast_length) => {
                    if (data.length < 24) return [];

                    const { n_estimators, learning_rate, max_depth, subsample } = params;
                    const horizon = forecast_length ?? 12;
                    const predictions = [];
                    
                    const features = engineerFeatures(data);
                    const targets = data.slice(12).map(d => d.sales);
                    
                    let models = [];
                    let residuals = [...targets];
                    
                    for (let i = 0; i < n_estimators; i++) {
                        const sampled_features = features.filter(() => Math.random() < subsample);
                        const tree = fitDecisionTree(sampled_features, residuals, max_depth);
                        const predictions_tree = tree.predict(features);
                        
                        residuals = residuals.map((r, idx) => r - learning_rate * predictions_tree[idx]);
                        models.push({ tree, weight: learning_rate });
                        
                        if (Math.abs(residuals.reduce((sum, r) => sum + r, 0)) < 0.01) break;
                    }
                    
                    for (let i = 1; i <= horizon; i++) {
                        const future_features = createFutureFeatures(data, i);
                        let prediction = data[data.length - 1].sales;
                        
                        models.forEach(model => {
                            prediction += model.weight * model.tree.predict([future_features])[0];
                        });
                        
                        predictions.push({
                            year: 2025,
                            month: i,
                            sales: Math.round(Math.max(0, prediction)),
                            date: `2025-${i.toString().padStart(2, '0')}`,
                            type: 'predicted'
                        });
                    }
                    
                    return predictions;
                },

                // üöÄ N-BEATS Îî•Îü¨Îãù
                nbeats_model: (data, params) => {
                    if (data.length < 48) return [];
                    
                    const { num_blocks, stack_weight, forecast_length, backcast_length } = params;
                    const predictions = [];
                    
                    const sales = data.map(d => d.sales);
                    const normalized = normalizeData(sales);
                    
                    let forecast = Array(forecast_length).fill(0);
                    let backcast = [...normalized.slice(-backcast_length)];
                    
                    const stack_types = ['trend', 'seasonal'];
                    
                    stack_types.forEach(stack_type => {
                        for (let block = 0; block < num_blocks; block++) {
                            const { block_forecast, block_backcast } = nbeatsBlock(backcast, stack_type, stack_weight, forecast_length);
                            
                            forecast = forecast.map((f, i) => f + block_forecast[i] * stack_weight);
                            backcast = backcast.map((b, i) => b - (block_backcast[i] || 0) * stack_weight);
                        }
                    });
                    
                    for (let i = 0; i < forecast_length; i++) {
                        const denorm_pred = denormalizeData(forecast[i], sales);
                        
                        predictions.push({
                            year: 2025,
                            month: i + 1,
                            sales: Math.round(Math.max(0, denorm_pred)),
                            date: `2025-${(i + 1).toString().padStart(2, '0')}`,
                            type: 'predicted'
                        });
                    }
                    
                    return predictions;
                }
            };

            // üéØ Ìó¨Ìçº Ìï®ÏàòÎì§
            const normalizeData = (data) => {
                const min = Math.min(...data);
                const max = Math.max(...data);
                return data.map(val => (val - min) / (max - min));
            };

            const denormalizeData = (normalized, original) => {
                const min = Math.min(...original);
                const max = Math.max(...original);
                return normalized * (max - min) + min;
            };

            const createSequences = (data, length) => {
                const sequences = [];
                for (let i = length; i < data.length; i++) {
                    sequences.push(data.slice(i - length, i));
                }
                return sequences;
            };

            const calculateAttentionWeights = (sequences, heads, forecast_length) => {
                return Array(heads).fill().map(() =>
                    Array(forecast_length).fill().map(() => Math.random())
                );
            };

            const applyAttention = (sequences, weights, forecast_length) => {
                const last_seq = sequences[sequences.length - 1] || [];
                const seq = Array(forecast_length).fill(0).map((_, i) => last_seq[i] || 0);
                return seq.map(val => val * (0.8 + Math.random() * 0.4));
            };

            const gruCell = (input, hidden, dropout) => {
                const reset_gate = sigmoid(input * 0.5 + hidden.reduce((sum, h) => sum + h, 0) * 0.01);
                const update_gate = sigmoid(input * 0.3 + hidden.reduce((sum, h) => sum + h, 0) * 0.01);
                const new_gate = Math.tanh(input * 0.4 + reset_gate * hidden.reduce((sum, h) => sum + h, 0) * 0.01);
                
                return hidden.map(h => {
                    const cell = update_gate * h + (1 - update_gate) * new_gate;
                    return Math.random() > dropout ? cell : 0; // ÎìúÎ°≠ÏïÑÏõÉ Ï†ÅÏö©
                });
            };

            const gruPredict = (hidden, step, lr) => {
                const sum = hidden.reduce((sum, h) => sum + h, 0) / hidden.length;
                return sum * (1 - step * lr);
            };

            const sigmoid = (x) => 1 / (1 + Math.exp(-x));

            // Í∏∞Î≥∏ ÏïåÍ≥†Î¶¨Ï¶òÎì§
            const linearTrend = (data, params, forecast_length) => {
                const { growth_rate, seasonal_factor } = params;
                const predictions = [];
                const recentSales = data.slice(-6).reduce((sum, d) => sum + d.sales, 0) / 6;

                for (let i = 1; i <= forecast_length; i++) {
                    const seasonal = 1 + seasonal_factor * Math.sin((i - 1) / 12 * 2 * Math.PI);
                    const predicted = recentSales * (1 + growth_rate) * seasonal;

                    predictions.push({
                        year: 2025,
                        month: i,
                        sales: Math.round(Math.max(0, predicted)),
                        date: `2025-${i.toString().padStart(2, '0')}`,
                        type: 'predicted'
                    });
                }
                return predictions;
            };

            const seasonalDecompose = (data, params, forecast_length) => {
                const predictions = [];
                const { strength } = params;

                const monthlyAvg = Array(12).fill(0).map((_, month) => {
                    const monthData = data.filter(d => d.month === month + 1);
                    return monthData.length > 0
                        ? monthData.reduce((sum, d) => sum + d.sales, 0) / monthData.length
                        : 0;
                });

                for (let i = 1; i <= forecast_length; i++) {
                    predictions.push({
                        year: 2025,
                        month: i,
                        sales: Math.round(Math.max(0, monthlyAvg[(i - 1) % 12] * strength)),
                        date: `2025-${i.toString().padStart(2, '0')}`,
                        type: 'predicted'
                    });
                }
                return predictions;
            };

            const movingAverage = (data, params, forecast_length) => {
                const { window, trend_adj } = params;
                const predictions = [];
                const recentData = data.slice(-window);
                const avgSales = recentData.reduce((sum, d) => sum + d.sales, 0) / recentData.length;

                for (let i = 1; i <= forecast_length; i++) {
                    predictions.push({
                        year: 2025,
                        month: i,
                        sales: Math.round(Math.max(0, avgSales * (1 + trend_adj))),
                        date: `2025-${i.toString().padStart(2, '0')}`,
                        type: 'predicted'
                    });
                }
                return predictions;
            };

            const exponentialSmoothing = (data, params, forecast_length) => {
                const { alpha, beta, gamma } = params;
                const predictions = [];

                const recentSales = data[data.length - 1].sales;
                const trend = data.length >= 12 ?
                    (data[data.length - 1].sales - data[data.length - 12].sales) / 12 : 0;

                for (let i = 1; i <= forecast_length; i++) {
                    const seasonal = 1 + gamma * Math.sin((i - 1) / 12 * 2 * Math.PI);
                    const forecast = (recentSales + trend * i) * seasonal;

                    predictions.push({
                        year: 2025,
                        month: i,
                        sales: Math.round(Math.max(0, forecast)),
                        date: `2025-${i.toString().padStart(2, '0')}`,
                        type: 'predicted'
                    });
                }
                return predictions;
            };

            // Ï∂îÍ∞Ä Ìó¨Ìçº Ìï®ÏàòÎì§
            const waveletDecompose = (data, levels) => {
                const components = [];
                let current = [...data];
                
                for (let level = 0; level < levels; level++) {
                    const filtered = current.map((val, idx) => 
                        idx % 2 === 0 ? val * 0.7 + (current[idx + 1] || 0) * 0.3 : val * 0.3 + (current[idx - 1] || 0) * 0.7
                    );
                    components.push(filtered);
                    current = filtered.filter((_, idx) => idx % 2 === 0);
                }
                
                return components;
            };

            const waveletReconstruct = (components) => {
                return components.reduce((sum, val) => sum + (val || 0), 0);
            };

            const arimaForecast = (data, order, steps) => {
                const [p, d, q] = order;
                const forecast = [];
                const recent = data.slice(-p);
                
                for (let i = 0; i < steps; i++) {
                    const predicted = recent.reduce((sum, val, idx) => sum + val * (1 - idx * 0.1), 0) / recent.length;
                    forecast.push(predicted);
                }
                
                return forecast;
            };

            const engineerFeatures = (data) => {
                return data.map((d, idx) => [
                    d.sales,
                    d.month,
                    Math.sin(d.month / 12 * 2 * Math.PI),
                    Math.cos(d.month / 12 * 2 * Math.PI),
                    idx < 12 ? 0 : data[idx - 12].sales,
                    idx < 1 ? 0 : data[idx - 1].sales
                ]);
            };

            const fitDecisionTree = (features, targets, maxDepth) => {
                return {
                    predict: (X) => X.map(x => x[0] * 0.9 + Math.random() * x[0] * 0.2)
                };
            };

            const createFutureFeatures = (data, month) => {
                const lastSales = data[data.length - 1].sales;
                return [
                    lastSales,
                    month,
                    Math.sin(month / 12 * 2 * Math.PI),
                    Math.cos(month / 12 * 2 * Math.PI),
                    lastSales,
                    lastSales
                ];
            };

            const nbeatsBlock = (input, stackType, weight, forecast_length) => {
                const inputLength = input.length;
                
                let block_forecast, block_backcast;
                
                if (stackType === 'trend') {
                    const trend = (input[inputLength - 1] - input[0]) / inputLength;
                    block_forecast = Array.from({length: forecast_length}, (_, i) =>
                        input[inputLength - 1] + trend * (i + 1) * weight
                    );
                    block_backcast = input.map((val, i) => val + trend * 0.1 * weight);
                } else {
                    block_forecast = Array.from({length: forecast_length}, (_, i) =>
                        input[inputLength - 1] * (1 + 0.1 * Math.sin((i + 1) / 12 * 2 * Math.PI)) * weight
                    );
                    block_backcast = input.map((val, i) => 
                        val * (1 + 0.05 * Math.sin(i / 12 * 2 * Math.PI)) * weight
                    );
                }
                
                return { block_forecast, block_backcast };
            };

            // üéØ ÌïÑÌÑ∞ÎßÅÎêú Îç∞Ïù¥ÌÑ∞
            const filteredData = useMemo(() => {
                return historicalData.filter(d => {
                    return (selectedCountry === 'Ï†ÑÏ≤¥' || d.country === selectedCountry) &&
                           (selectedProduct === 'Ï†ÑÏ≤¥' || d.product === selectedProduct);
                });
            }, [historicalData, selectedCountry, selectedProduct]);

            // üéØ ÏßëÍ≥ÑÎêú Îç∞Ïù¥ÌÑ∞
            const aggregatedData = useMemo(() => {
                const grouped = {};
                filteredData.forEach(d => {
                    const key = `${d.year}-${d.month.toString().padStart(2, '0')}`;
                    if (!grouped[key]) {
                        grouped[key] = { year: d.year, month: d.month, date: key, sales: 0 };
                    }
                    grouped[key].sales += d.sales;
                });
                return Object.values(grouped).sort((a, b) => a.year - b.year || a.month - b.month);
            }, [filteredData]);

            // üéØ Íµ≠Í∞Ä Î∞è Ï†úÌíà Î™©Î°ù
            const countries = useMemo(() => {
                const countrySet = new Set(historicalData.map(d => d.country));
                return ['Ï†ÑÏ≤¥', ...Array.from(countrySet).sort()];
            }, [historicalData]);

            const products = useMemo(() => {
                const productSet = new Set(historicalData.map(d => d.product));
                return ['Ï†ÑÏ≤¥', ...Array.from(productSet).sort()];
            }, [historicalData]);

            // üéØ ÏòàÏ∏° Í≤∞Í≥º
            const predictions = useMemo(() => {
                if (aggregatedData.length === 0) return [];
                setIsLoading(true);

                try {

                    const params = { ...algorithmParameters[selectedAlgorithm], forecast_length: forecastPeriod };

                    const result = algorithms[selectedAlgorithm](
                        aggregatedData,
                        params,
                        forecastPeriod
                    );
                    setTimeout(() => setIsLoading(false), 500);
                    return result;
                } catch (error) {
                    console.error('ÏòàÏ∏° Ïò§Î•ò:', error);
                    setIsLoading(false);
                    showToast('ÏòàÏ∏° Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', 'error');
                    return [];
                }
            }, [aggregatedData, selectedAlgorithm, algorithmParameters, forecastPeriod]);

            // üéØ ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
            const stats = useMemo(() => {
                const totalPredicted = predictions.reduce((sum, p) => sum + p.sales, 0);
                const predicted2025 = predictions.slice(0, 12).reduce((sum, p) => sum + p.sales, 0);
                const total2024 = aggregatedData.filter(d => d.year === 2024).reduce((sum, d) => sum + d.sales, 0);
                const growthRate = total2024 > 0 ? ((predicted2025 - total2024) / total2024 * 100) : 0;
                const avgMonthly2025 = predicted2025 / 12;

                return {
                    total2024,
                    totalPredicted,
                    predicted2025,
                    growthRate,
                    avgMonthly2025
                };
            }, [predictions, aggregatedData]);

            // üéØ CSV ÏóÖÎ°úÎìú Ï≤òÎ¶¨
            const handleFileUpload = async (event) => {
                const file = event.target.files[0];
                if (!file || file.type !== 'text/csv') {
                    showToast('CSV ÌååÏùºÎßå ÏóÖÎ°úÎìú Í∞ÄÎä•Ìï©ÎãàÎã§.', 'error');
                    return;
                }

                setIsLoading(true);
                try {
                    const text = await file.text();
                    const lines = text.split('\n');
                    const headers = lines[0].split(',').map(h => h.trim());
                    
                    const parsedData = [];
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i].trim()) {
                            const values = lines[i].split(',');
                            const row = {};
                            headers.forEach((header, index) => {
                                row[header] = values[index]?.trim();
                            });
                            
                            if (row.year && row.month && row.sales) {
                                parsedData.push({
                                    year: parseInt(row.year),
                                    month: parseInt(row.month),
                                    country: row.country || 'Í∏∞ÌÉÄ',
                                    product: row.product || 'Í∏∞ÌÉÄ',
                                    sales: parseFloat(row.sales),
                                    date: `${row.year}-${row.month.toString().padStart(2, '0')}`
                                });
                            }
                        }
                    }
                    
                    if (parsedData.length > 0) {
                        setHistoricalData(parsedData);
                        showToast(`${parsedData.length}Í∞úÏùò Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏóÖÎ°úÎìúÎêòÏóàÏäµÎãàÎã§!`, 'success');
                    } else {
                        showToast('Ïò¨Î∞îÎ•∏ ÌòïÏãùÏùò CSV ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.', 'error');
                    }
                } catch (error) {
                    showToast('ÌååÏùºÏùÑ ÏùΩÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', 'error');
                    console.error('File parsing error:', error);
                } finally {
                    setIsLoading(false);
                }
            };

            // üéØ CSV ÎÇ¥Î≥¥ÎÇ¥Í∏∞
            const exportResults = () => {
                const exportData = [
                    ['ÎÇ†Ïßú', 'ÏòàÏ∏° Îß§Ï∂ú (ÎßåÏõê)', 'Íµ≠Í∞Ä', 'Ï†úÌíà', 'ÏïåÍ≥†Î¶¨Ï¶ò', 'ÌååÎùºÎ©îÌÑ∞'],
                    ...predictions.map(pred => [
                        pred.date,
                        pred.sales,
                        selectedCountry,
                        selectedProduct,
                        selectedAlgorithm,
                        JSON.stringify(algorithmParameters[selectedAlgorithm])
                    ])
                ];

                const csvContent = exportData.map(row => row.join(',')).join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `Îß§Ï∂úÏòàÏ∏°Í≤∞Í≥º_${selectedAlgorithm}_${new Date().toISOString().split('T')[0]}.csv`;
                link.click();
                
                showToast('ÏòàÏ∏° Í≤∞Í≥ºÍ∞Ä CSV ÌååÏùºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!', 'success');
            };

            // üéØ ÏïåÍ≥†Î¶¨Ï¶ò ÏÑ§Î™Ö Î∞è ÌååÎùºÎ©îÌÑ∞ Ï†ïÎ≥¥
            const algorithmInfo = {
                advanced_ensemble: {
                    name: "üöÄ Í≥†Í∏â ÏïôÏÉÅÎ∏î",
                    description: "4Í∞úÏùò ÏÑúÎ°ú Îã§Î•∏ ÏòàÏ∏° Î™®Îç∏(Ï∂îÏÑ∏, Í≥ÑÏ†àÏÑ±, Ïù¥ÎèôÌèâÍ∑†, ÏßÄÏàòÌèâÌôú)ÏùÑ ÏµúÏ†Å Í∞ÄÏ§ëÏπòÎ°ú Í≤∞Ìï©ÌïòÏó¨ ÎçîÏö± Ï†ïÌôïÌïòÍ≥† ÏïàÏ†ïÏ†ÅÏù∏ ÏòàÏ∏°ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§. Í∞Å Î™®Îç∏Ïùò Ïû•Ï†êÏùÑ Í≤∞Ìï©ÌïòÏó¨ Îã®Ïùº Î™®Îç∏Ïùò ÌïúÍ≥ÑÎ•º Í∑πÎ≥µÌï©ÎãàÎã§.",
                    parameters: {
                        trend_weight: { min: 0, max: 1, step: 0.1, suffix: "", description: "Ï∂îÏÑ∏ Î™®Îç∏Ïùò Í∞ÄÏ§ëÏπò - Îç∞Ïù¥ÌÑ∞Ïùò Ïû•Í∏∞Ï†Å Ï¶ùÍ∞Ä/Í∞êÏÜå Ìå®ÌÑ¥ Î∞òÏòÅ Ï†ïÎèÑ" },
                        seasonal_weight: { min: 0, max: 1, step: 0.1, suffix: "", description: "Í≥ÑÏ†àÏÑ± Î™®Îç∏Ïùò Í∞ÄÏ§ëÏπò - ÏõîÎ≥Ñ/Î∂ÑÍ∏∞Î≥Ñ Î∞òÎ≥µ Ìå®ÌÑ¥ Î∞òÏòÅ Ï†ïÎèÑ" },
                        ma_weight: { min: 0, max: 1, step: 0.1, suffix: "", description: "Ïù¥ÎèôÌèâÍ∑† Î™®Îç∏Ïùò Í∞ÄÏ§ëÏπò - ÏµúÍ∑º ÌèâÍ∑†Í∞í Í∏∞Î∞ò ÏïàÏ†ïÏ†Å ÏòàÏ∏° Î∞òÏòÅ Ï†ïÎèÑ" },
                        exp_weight: { min: 0, max: 1, step: 0.1, suffix: "", description: "ÏßÄÏàòÌèâÌôú Î™®Îç∏Ïùò Í∞ÄÏ§ëÏπò - ÏµúÍ∑º Îç∞Ïù¥ÌÑ∞Ïóê Îçî ÎÜíÏùÄ Í∞ÄÏ§ëÏπòÎ•º Îëî ÏòàÏ∏° Î∞òÏòÅ Ï†ïÎèÑ" },
                        forecast_length: { min: 1, max: 12, step: 1, suffix: "Í∞úÏõî", description: "ÏòàÏ∏° Í∏∏Ïù¥ - Ìñ•ÌõÑ ÏòàÏ∏°Ìï† Í∏∞Í∞Ñ" }
                    }
                },
                transformer_model: {
                    name: "ü§ñ Transformer",
                    description: "ÏµúÏã† AI Í∏∞Ïà†Ïù∏ Self-Attention Î©îÏª§ÎãàÏ¶òÏùÑ ÌôúÏö©Ìï¥ ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞Ïùò Î≥µÏû°Ìïú Ìå®ÌÑ¥Í≥º Ïû•Í∏∞ ÏùòÏ°¥ÏÑ±ÏùÑ ÌïôÏäµÌï©ÎãàÎã§. ÏûêÏó∞Ïñ¥ Ï≤òÎ¶¨ÏóêÏÑú Í≤ÄÏ¶ùÎêú Ïñ¥ÌÖêÏÖò Í∏∞Î≤ïÏùÑ ÏãúÍ≥ÑÏó¥ ÏòàÏ∏°Ïóê Ï†ÅÏö©Ìïú Î™®Îç∏ÏûÖÎãàÎã§.",
                    parameters: {
                        attention_heads: { min: 4, max: 16, step: 2, suffix: "Í∞ú", description: "Ïñ¥ÌÖêÏÖò Ìó§Îìú Ïàò - Îã§ÏñëÌïú Í¥ÄÏ†êÏóêÏÑú Ìå®ÌÑ¥ÏùÑ ÌïôÏäµÌïòÎäî Î≥ëÎ†¨ Ï≤òÎ¶¨ Îã®ÏúÑ Ïàò" },
                        model_dim: { min: 32, max: 128, step: 16, suffix: "", description: "Î™®Îç∏ Ï∞®Ïõê - ÎÇ¥Î∂Ä ÌëúÌòÑÏùò Î≥µÏû°ÎèÑÏôÄ ÌïôÏäµ Ïö©ÎüâÏùÑ Í≤∞Ï†ï" },
                        learning_rate: { min: 0.0001, max: 0.01, step: 0.0001, suffix: "", description: "ÌïôÏäµÎ•† - Î™®Îç∏Ïù¥ Ìå®ÌÑ¥ÏùÑ ÌïôÏäµÌïòÎäî ÏÜçÎèÑ, ÎÑàÎ¨¥ ÎÜíÏúºÎ©¥ Î∂àÏïàÏ†ï" },
                        sequence_length: { min: 6, max: 24, step: 2, suffix: "Í∞úÏõî", description: "ÏûÖÎ†• ÏãúÌÄÄÏä§ Í∏∏Ïù¥ - ÏòàÏ∏°ÏùÑ ÏúÑÌï¥ Ï∞∏Í≥†ÌïòÎäî Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞ Í∏∞Í∞Ñ" },
                        forecast_length: { min: 1, max: 24, step: 1, suffix: "Í∞úÏõî", description: "ÏòàÏ∏° Í∏∏Ïù¥ - Ìñ•ÌõÑ ÏòàÏ∏°Ìï† Í∏∞Í∞Ñ" }
                    }
                },
                gru_network: {
                    name: "üß† GRU Ïã†Í≤ΩÎßù",
                    description: "LSTMÎ≥¥Îã§ Ìö®Ïú®Ï†ÅÏù∏ ÏàúÌôò Ïã†Í≤ΩÎßùÏúºÎ°ú Ïû•Í∏∞ ÏùòÏ°¥ÏÑ±ÏùÑ Ìö®Í≥ºÏ†ÅÏúºÎ°ú Î™®Îç∏ÎßÅÌï©ÎãàÎã§. Í≤åÏù¥Ìä∏ Î©îÏª§ÎãàÏ¶òÏùÑ ÌÜµÌï¥ Ï§ëÏöîÌïú Ï†ïÎ≥¥Îäî Í∏∞ÏñµÌïòÍ≥† Î∂àÌïÑÏöîÌïú Ï†ïÎ≥¥Îäî ÎßùÍ∞ÅÌïòÏó¨ Ï†ïÌôïÌïú ÏãúÍ≥ÑÏó¥ ÏòàÏ∏°ÏùÑ ÏàòÌñâÌï©ÎãàÎã§.",
                    parameters: {
                        hidden_size: { min: 16, max: 128, step: 8, suffix: "", description: "ÏùÄÎãâ Ïú†Îãõ Ïàò - ÎÑ§Ìä∏ÏõåÌÅ¨Ïùò Í∏∞Ïñµ Ïö©ÎüâÍ≥º ÌïôÏäµ Î≥µÏû°ÎèÑ Í≤∞Ï†ï" },
                        sequence_length: { min: 6, max: 24, step: 2, suffix: "Í∞úÏõî", description: "ÏûÖÎ†• ÏãúÌÄÄÏä§ Í∏∏Ïù¥ - GRUÍ∞Ä Í∏∞ÏñµÌï† Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞Ïùò Î≤îÏúÑ" },
                        learning_rate: { min: 0.001, max: 0.1, step: 0.001, suffix: "", description: "ÌïôÏäµÎ•† - Í∞ÄÏ§ëÏπò ÏóÖÎç∞Ïù¥Ìä∏ ÌÅ¨Í∏∞, ÏàòÎ†¥ ÏÜçÎèÑÏôÄ ÏïàÏ†ïÏÑ±Ïóê ÏòÅÌñ•" },
                        dropout_rate: { min: 0.1, max: 0.5, step: 0.1, suffix: "", description: "ÎìúÎ°≠ÏïÑÏõÉ ÎπÑÏú® - Í≥ºÏ†ÅÌï© Î∞©ÏßÄÎ•º ÏúÑÌï¥ ÏùºÏ†ï ÎπÑÏú®Ïùò Îâ¥Îü∞ÏùÑ ÎπÑÌôúÏÑ±Ìôî" },
                        forecast_length: { min: 1, max: 24, step: 1, suffix: "Í∞úÏõî", description: "ÏòàÏ∏° Í∏∏Ïù¥ - Ìñ•ÌõÑ ÏòàÏ∏°Ìï† Í∏∞Í∞Ñ" }
                    }
                },
                wavelet_arima: {
                    name: "üìä Ïõ®Ïù¥Î∏îÎ¶ø+ARIMA",
                    description: "Ïõ®Ïù¥Î∏îÎ¶ø Î≥ÄÌôòÏúºÎ°ú ÏãúÍ≥ÑÏó¥ÏùÑ Îã§Ï§ë Ìï¥ÏÉÅÎèÑÎ°ú Î∂ÑÌï¥Ìïú ÌõÑ Í∞Å ÏÑ±Î∂ÑÏóê ARIMA Î™®Îç∏ÏùÑ Ï†ÅÏö©ÌïòÎäî ÌïòÏù¥Î∏åÎ¶¨Îìú Ï†ëÍ∑ºÎ≤ïÏûÖÎãàÎã§. Ïã†Ìò∏ Ï≤òÎ¶¨ Í∏∞Î≤ïÍ≥º Ï†ÑÌÜµÏ†Å ÌÜµÍ≥Ñ Î™®Îç∏ÏùÑ Í≤∞Ìï©ÌïòÏó¨ Î≥µÏû°Ìïú Ìå®ÌÑ¥ÏùÑ Ìö®Í≥ºÏ†ÅÏúºÎ°ú Î™®Îç∏ÎßÅÌï©ÎãàÎã§.",
                    parameters: {
                        decomp_levels: { min: 2, max: 5, step: 1, suffix: "Îã®Í≥Ñ", description: "Î∂ÑÌï¥ Î†àÎ≤® Ïàò - Ïõ®Ïù¥Î∏îÎ¶ø Î∂ÑÌï¥Ïùò ÏÑ∏Î∞ÄÌï® Ï†ïÎèÑ, ÎÜíÏùÑÏàòÎ°ù Îçî ÏÑ∏Î∂ÄÏ†Å Î∂ÑÏÑù" },
                        arima_p: { min: 1, max: 5, step: 1, suffix: "", description: "AR Ï∞®Ïàò - ÏûêÍ∏∞ÌöåÍ∑Ä Ìï≠Ïùò Ïàò, Í≥ºÍ±∞ Í∞íÏùò ÏßÅÏ†ëÏ†Å ÏòÅÌñ• Ï†ïÎèÑ" },
                        arima_d: { min: 0, max: 2, step: 1, suffix: "", description: "Ï∞®Î∂Ñ Ï∞®Ïàò - ÎπÑÏ†ïÏÉÅÏÑ± Ï†úÍ±∞Î•º ÏúÑÌïú Ï∞®Î∂Ñ ÌöüÏàò, Ï∂îÏÑ∏ Ï†úÍ±∞ Ï†ïÎèÑ" },
                        arima_q: { min: 1, max: 5, step: 1, suffix: "", description: "MA Ï∞®Ïàò - Ïù¥ÎèôÌèâÍ∑† Ìï≠Ïùò Ïàò, Í≥ºÍ±∞ Ïò§Ï∞®Ïùò ÏòÅÌñ• Ï†ïÎèÑ" }
                    }
                },
                gradient_boosting: {
                    name: "‚ö° Í∑∏ÎùºÎîîÏñ∏Ìä∏ Î∂ÄÏä§ÌåÖ",
                    description: "XGBoost Ïä§ÌÉÄÏùºÏùò Î∂ÄÏä§ÌåÖ ÏïåÍ≥†Î¶¨Ï¶òÏúºÎ°ú Ïó¨Îü¨ ÏïΩÌïú ÏòàÏ∏°Í∏∞(ÏùòÏÇ¨Í≤∞Ï†ïÌä∏Î¶¨)Î•º ÏàúÏ∞®Ï†ÅÏúºÎ°ú Í≤∞Ìï©ÌïòÏó¨ Í∞ïÎ†•Ìïú ÏòàÏ∏° Î™®Îç∏ÏùÑ Íµ¨Ï∂ïÌï©ÎãàÎã§. Í∞Å Îã®Í≥ÑÏóêÏÑú Ïù¥Ï†Ñ Î™®Îç∏Ïùò Ïò§Ï∞®Î•º Î≥¥Ï†ïÌïòÏó¨ ÏÑ±Îä•ÏùÑ Ìñ•ÏÉÅÏãúÌÇµÎãàÎã§.",
                    parameters: {
                        n_estimators: { min: 50, max: 200, step: 10, suffix: "Í∞ú", description: "Ï∂îÏ†ïÍ∏∞ Ïàò - Î∂ÄÏä§ÌåÖÏóê ÏÇ¨Ïö©Ìï† ÏïΩÌïú ÌïôÏäµÍ∏∞Ïùò Ï¥ù Í∞úÏàò" },
                        learning_rate: { min: 0.01, max: 0.3, step: 0.01, suffix: "", description: "ÌïôÏäµÎ•† - Í∞Å Î∂ÄÏä§ÌåÖ Îã®Í≥ÑÏùò Í∏∞Ïó¨ÎèÑ, ÎÇÆÏùÑÏàòÎ°ù ÏïàÏ†ïÏ†ÅÏù¥ÏßÄÎßå ÎäêÎ¶º" },
                        max_depth: { min: 3, max: 10, step: 1, suffix: "", description: "ÏµúÎåÄ ÍπäÏù¥ - Í∞úÎ≥Ñ Ìä∏Î¶¨Ïùò Î≥µÏû°ÎèÑ, ÎÜíÏùÑÏàòÎ°ù Î≥µÏû°Ìïú Ìå®ÌÑ¥ ÌïôÏäµ Í∞ÄÎä•" },
                        subsample: { min: 0.5, max: 1.0, step: 0.1, suffix: "", description: "ÏÑúÎ∏åÏÉòÌîå ÎπÑÏú® - Í∞Å Ìä∏Î¶¨ ÌïôÏäµÏãú ÏÇ¨Ïö©Ìï† Îç∞Ïù¥ÌÑ∞ ÎπÑÏú®, Í≥ºÏ†ÅÌï© Î∞©ÏßÄ" },
                        forecast_length: { min: 6, max: 24, step: 1, suffix: "Í∞úÏõî", description: "ÏòàÏ∏° Í∏∏Ïù¥ - Ìñ•ÌõÑ ÏòàÏ∏°Ìï† Í∏∞Í∞Ñ" }
                    }
                },
                nbeats_model: {
                    name: "üî• N-BEATS",
                    description: "ÏàúÏàò Îî•Îü¨Îãù Í∏∞Î∞ò ÏãúÍ≥ÑÏó¥ ÏòàÏ∏° Î™®Îç∏Î°ú Ìä∏Î†åÎìúÏôÄ Í≥ÑÏ†àÏÑ±ÏùÑ ÏûêÎèôÏúºÎ°ú Î∂ÑÌï¥ÌïòÏó¨ ÎÜíÏùÄ Ï†ïÌôïÎèÑÏùò ÏòàÏ∏°ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§. Î∞±Ï∫êÏä§ÌåÖÍ≥º Ìè¨Ï∫êÏä§ÌåÖÏùÑ ÎèôÏãúÏóê ÌïôÏäµÌïòÏó¨ Ìï¥ÏÑù Í∞ÄÎä•Ìïú ÏòàÏ∏° Í≤∞Í≥ºÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§.",
                    parameters: {
                        num_blocks: { min: 2, max: 5, step: 1, suffix: "Í∞ú", description: "Î∏îÎ°ù Ïàò - Í∞Å Ïä§ÌÉù ÎÇ¥ Î∏îÎ°ù Í∞úÏàò, Î™®Îç∏Ïùò ÍπäÏù¥ÏôÄ Î≥µÏû°ÎèÑ Í≤∞Ï†ï" },
                        stack_weight: { min: 0.1, max: 1.0, step: 0.1, suffix: "", description: "Ïä§ÌÉù Í∞ÄÏ§ëÏπò - Ìä∏Î†åÎìú/Í≥ÑÏ†àÏÑ± Ïä§ÌÉùÏùò Í∏∞Ïó¨ÎèÑ Ï°∞Ï†à" },
                        forecast_length: { min: 12, max: 24, step: 12, suffix: "Í∞úÏõî", description: "ÏòàÏ∏° Í∏∏Ïù¥ - Ìñ•ÌõÑ ÏòàÏ∏°Ìï† Í∏∞Í∞Ñ (12 ÎòêÎäî 24Í∞úÏõî)" },
                        backcast_length: { min: 12, max: 36, step: 12, suffix: "Í∞úÏõî", description: "Î∞±Ï∫êÏä§Ìä∏ Í∏∏Ïù¥ - ÌïôÏäµÏóê ÏÇ¨Ïö©Ìï† Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞ Í∏∏Ïù¥" }
                    }
                }
            };

            // üéØ ÌååÎùºÎ©îÌÑ∞ Î†åÎçîÎßÅ Ìï®Ïàò
            const renderParameters = () => {
                const info = algorithmInfo[selectedAlgorithm];
                if (!info) return null;

                return (
                    <div className="parameter-section">
                        <div className="flex justify-between items-center mb-3">
                            <h4 className="font-semibold text-gray-800">ÌååÎùºÎ©îÌÑ∞ Ï°∞Ï†ï</h4>
                            <button
                                onClick={resetParameters}
                                className="btn-reset"
                                disabled={isLoading}
                            >
                                <i className="fas fa-undo"></i>
                                Í∏∞Î≥∏Í∞íÏúºÎ°ú Î¶¨ÏÖã
                            </button>
                        </div>
                        
                        <div className="parameter-grid">
                            {Object.entries(info.parameters)
                                .filter(([key]) => key !== 'forecast_length')
                                .map(([key, config]) => (
                                    <ParameterControl
                                        key={key}
                                        label={key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}
                                        value={algorithmParameters[selectedAlgorithm][key]}
                                        min={config.min}
                                        max={config.max}
                                        step={config.step}
                                        suffix={config.suffix}
                                        description={config.description}
                                        onChange={(value) => updateParameter(selectedAlgorithm, key, value)}
                                    />
                                ))}
                        </div>
                    </div>
                );
            };

            return (
                <div className="app-container">
                    <Toast 
                        message={toast.message} 
                        type={toast.type} 
                        show={toast.show} 
                        onClose={hideToast} 
                    />

                    <div className="header">
                        <h1><i className="fas fa-rocket"></i> Advanced Îß§Ï∂ú ÏòàÏ∏° ÏãúÎÆ¨Î†àÏù¥ÌÑ∞ Pro</h1>
                        <p>ÏµúÏã† AI Í∏∞Ïà†ÏùÑ ÌôúÏö©Ìïú Ï∞®ÏÑ∏ÎåÄ Îß§Ï∂ú ÏòàÏ∏° ÏÜîÎ£®ÏÖò - ÌååÎùºÎ©îÌÑ∞ ÌäúÎãù ÏßÄÏõê</p>
                    </div>

                    <div className="container">
                        {/* ÌÜµÍ≥Ñ ÏöîÏïΩ */}
                        <div className="stats-grid">
                            <div className="stat-card">
                                <div className="stat-value text-blue-600">
                                    {stats.total2024.toLocaleString()}ÎßåÏõê
                                </div>
                                <div className="stat-label">2024ÎÖÑ Ïã§Ï†ú Îß§Ï∂ú</div>
                            </div>
                            <div className="stat-card">
                                <div className="stat-value text-purple-600">
                                    {stats.predicted2025.toLocaleString()}ÎßåÏõê
                                </div>
                                <div className="stat-label">2025ÎÖÑ ÏòàÏÉÅ Îß§Ï∂ú</div>
                            </div>
                            {forecastPeriod === 24 && (
                                <div className="stat-card">
                                    <div className="stat-value text-pink-600">
                                        {stats.totalPredicted.toLocaleString()}ÎßåÏõê
                                    </div>
                                    <div className="stat-label">Ï¥ù 24Í∞úÏõî ÏòàÏÉÅ Îß§Ï∂ú</div>
                                </div>
                            )}
                            <div className="stat-card">
                                <div className={`stat-value ${stats.growthRate >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                                    {stats.growthRate.toFixed(1)}%
                                </div>
                                <div className="stat-label">ÏÑ±Ïû•Î•†</div>
                            </div>
                            <div className="stat-card">
                                <div className="stat-value text-indigo-600">
                                    {stats.avgMonthly2025.toLocaleString()}ÎßåÏõê
                                </div>
                                <div className="stat-label">Ïõî ÌèâÍ∑† Îß§Ï∂ú</div>
                            </div>
                        </div>

                        <div className="grid">
                            {/* Ïª®Ìä∏Î°§ Ìå®ÎÑê */}
                            <div className="space-y-4">
                                {/* Îç∞Ïù¥ÌÑ∞ ÏóÖÎ°úÎìú */}
                                <div className="card">
                                    <div className="card-header">
                                        <i className="fas fa-upload text-blue-600"></i>
                                        <h2 className="card-title">Îç∞Ïù¥ÌÑ∞ ÏóÖÎ°úÎìú</h2>
                                    </div>
                                    <div className="form-group">
                                        <label className="form-label">CSV ÌååÏùº ÏóÖÎ°úÎìú</label>
                                        <input
                                            type="file"
                                            accept=".csv"
                                            onChange={handleFileUpload}
                                            className="form-input"
                                            disabled={isLoading}
                                        />
                                        <div className="text-xs text-gray-500 mt-2">
                                            <strong>ÌïÑÏàò:</strong> year, month, sales<br/>
                                            <strong>ÏÑ†ÌÉù:</strong> country, product
                                        </div>
                                    </div>
                                    
                                    <button 
                                        onClick={() => {
                                            setHistoricalData(generateSampleData());
                                            showToast('ÏÉòÌîå Îç∞Ïù¥ÌÑ∞Í∞Ä Îã§Ïãú Î°úÎìúÎêòÏóàÏäµÎãàÎã§!', 'success');
                                        }}
                                        className="btn btn-secondary mt-2"
                                        disabled={isLoading}
                                    >
                                        <i className="fas fa-refresh"></i>
                                        ÏÉòÌîå Îç∞Ïù¥ÌÑ∞ Ïû¨Î°úÎìú
                                    </button>
                                </div>

                                {/* ÌïÑÌÑ∞ ÏÑ§Ï†ï */}
                                <div className="card">
                                    <div className="card-header">
                                        <i className="fas fa-filter text-green-600"></i>
                                        <h2 className="card-title">ÌïÑÌÑ∞ ÏÑ§Ï†ï</h2>
                                    </div>
                                    <div className="space-y-4">
                                        <div className="form-group">
                                            <label className="form-label">
                                                <i className="fas fa-globe"></i> Íµ≠Í∞Ä
                                            </label>
                                            <select 
                                                value={selectedCountry}
                                                onChange={(e) => setSelectedCountry(e.target.value)}
                                                className="form-select"
                                                disabled={isLoading}
                                            >
                                                {countries.map(country => (
                                                    <option key={country} value={country}>{country}</option>
                                                ))}
                                            </select>
                                        </div>

                                        <div className="form-group">
                                            <label className="form-label">
                                                <i className="fas fa-box"></i> Ï†úÌíà
                                            </label>
                                            <select 
                                                value={selectedProduct}
                                                onChange={(e) => setSelectedProduct(e.target.value)}
                                                className="form-select"
                                                disabled={isLoading}
                                            >
                                                {products.map(product => (
                                                    <option key={product} value={product}>{product}</option>
                                                ))}
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                {/* AI ÏïåÍ≥†Î¶¨Ï¶ò ÏÑ†ÌÉù */}
                                <div className="card">
                                    <div className="card-header">
                                        <i className="fas fa-brain text-purple-600"></i>
                                        <h2 className="card-title">AI ÏïåÍ≥†Î¶¨Ï¶ò & ÌååÎùºÎ©îÌÑ∞</h2>
                                    </div>
                                    <div className="space-y-4">
                                        <div className="form-group">
                                            <label className="form-label">ÏòàÏ∏° Î™®Îç∏ ÏÑ†ÌÉù</label>
                                            <select
                                                value={selectedAlgorithm}
                                                onChange={(e) => setSelectedAlgorithm(e.target.value)}
                                                className="form-select"
                                                disabled={isLoading}
                                            >
                                                <optgroup label="üöÄ Í≥†Í∏â AI Î™®Îç∏">
                                                    <option value="advanced_ensemble">Í≥†Í∏â ÏïôÏÉÅÎ∏î</option>
                                                    <option value="transformer_model">Transformer</option>
                                                    <option value="gru_network">GRU Ïã†Í≤ΩÎßù</option>
                                                    <option value="wavelet_arima">Ïõ®Ïù¥Î∏îÎ¶ø+ARIMA</option>
                                                    <option value="gradient_boosting">Í∑∏ÎùºÎîîÏñ∏Ìä∏ Î∂ÄÏä§ÌåÖ</option>
                                                    <option value="nbeats_model">N-BEATS</option>
                                                </optgroup>
                                            </select>
                                        </div>

                                        <div className="form-group">
                                            <label className="form-label">ÏòàÏ∏° Í∏∞Í∞Ñ</label>
                                            <select
                                                value={forecastPeriod}
                                                onChange={(e) => setForecastPeriod(parseInt(e.target.value))}
                                                className="form-select"
                                                disabled={isLoading}
                                            >
                                                <option value={12}>12Í∞úÏõî</option>
                                                <option value={24}>24Í∞úÏõî</option>
                                            </select>
                                        </div>

                                        {/* ÏïåÍ≥†Î¶¨Ï¶ò ÏÑ§Î™Ö */}
                                        {algorithmInfo[selectedAlgorithm] && (
                                            <div className="algorithm-description">
                                                <div className="algorithm-badge badge-ai">
                                                    <i className="fas fa-robot"></i>
                                                    {algorithmInfo[selectedAlgorithm].name}
                                                </div>
                                                <p className="text-sm text-gray-700 mt-2">
                                                    {algorithmInfo[selectedAlgorithm].description}
                                                </p>
                                            </div>
                                        )}

                                        {/* ÌååÎùºÎ©îÌÑ∞ Ï°∞Ï†ï */}
                                        {renderParameters()}

                                        <div className="form-group">
                                            <label className="flex items-center">
                                                <input
                                                    type="checkbox"
                                                    checked={showConfidenceInterval}
                                                    onChange={(e) => setShowConfidenceInterval(e.target.checked)}
                                                    className="mr-2"
                                                    disabled={isLoading}
                                                />
                                                <span className="text-sm">95% Ïã†Î¢∞Íµ¨Í∞Ñ ÌëúÏãú</span>
                                            </label>
                                        </div>
                                    </div>
                                </div>

                                {/* Í≤∞Í≥º ÎÇ¥Î≥¥ÎÇ¥Í∏∞ */}
                                <div className="card">
                                    <div className="card-header">
                                        <i className="fas fa-download text-green-600"></i>
                                        <h2 className="card-title">Í≤∞Í≥º ÎÇ¥Î≥¥ÎÇ¥Í∏∞</h2>
                                    </div>
                                    <button 
                                        onClick={exportResults}
                                        className="btn btn-success w-full"
                                        disabled={isLoading || predictions.length === 0}
                                    >
                                        <i className="fas fa-file-csv"></i>
                                        CSV ÌååÏùºÎ°ú Ï†ÄÏû• (ÌååÎùºÎ©îÌÑ∞ Ìè¨Ìï®)
                                    </button>
                                </div>
                            </div>

                            {/* Ï∞®Ìä∏ Î∞è Í≤∞Í≥º */}
                            <div className="space-y-4">
                                {/* Ï∞®Ìä∏ */}
                                <div className="card">
                                    <div className="card-header">
                                        <i className="fas fa-chart-line text-blue-600"></i>
                                        <h2 className="card-title">Îß§Ï∂ú Ï∂îÏù¥ Î∞è AI ÏòàÏ∏°</h2>
                                        <span className="algorithm-badge badge-ai">
                                            {algorithmInfo[selectedAlgorithm]?.name}
                                        </span>
                                    </div>
                                    <div className="chart-container">
                                        <SalesChart 
                                            data={aggregatedData} 
                                            predictions={predictions} 
                                            showConfidenceInterval={showConfidenceInterval}
                                            isLoading={isLoading}
                                        />
                                    </div>
                                </div>

                                {/* ÏòàÏ∏° ÌÖåÏù¥Î∏î */}
                                <div className="card">
                                    <div className="card-header">
                                        <i className="fas fa-table text-purple-600"></i>
                                        <h2 className="card-title">2025ÎÖÑ ÏõîÎ≥Ñ ÏòàÏ∏°</h2>
                                        <div className="text-xs text-gray-500">
                                            ÌòÑÏû¨ ÌååÎùºÎ©îÌÑ∞Î°ú ÏÉùÏÑ±Îêú ÏòàÏ∏°
                                        </div>
                                    </div>
                                    
                                    {isLoading ? (
                                        <LoadingSpinner message="AI Î™®Îç∏ Í≥ÑÏÇ∞ Ï§ë..." />
                                    ) : (
                                        <div className="table-container">
                                            <table className="table">
                                                <thead>
                                                    <tr>
                                                        <th>Ïõî</th>
                                                        <th className="text-right">ÏòàÏ∏° Îß§Ï∂ú (ÎßåÏõê)</th>
                                                        <th className="text-right">Ï†ÑÎÖÑ ÎèôÏõî ÎåÄÎπÑ</th>
                                                        <th className="text-right">Ïã†Î¢∞Íµ¨Í∞Ñ</th>
                                                        <th>Î™®Îç∏</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {predictions.map((pred, index) => {
                                                        const sameMonthLastYear = aggregatedData.find(d => 
                                                            d.year === 2024 && d.month === pred.month
                                                        )?.sales || 0;
                                                        const growth = sameMonthLastYear > 0 ? 
                                                            ((pred.sales - sameMonthLastYear) / sameMonthLastYear * 100) : 0;

                                                        return (
                                                            <tr key={index}>
                                                                <td className="font-medium">{pred.month}Ïõî</td>
                                                                <td className="text-right font-bold text-blue-600">
                                                                    {pred.sales.toLocaleString()}
                                                                </td>
                                                                <td className={`text-right font-medium ${growth >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                                                                    {growth.toFixed(1)}%
                                                                </td>
                                                                <td className="text-right text-gray-500 text-xs">
                                                                    {showConfidenceInterval ? 
                                                                        `¬±${(pred.sales * 0.15).toFixed(0)}` : 
                                                                        'N/A'}
                                                                </td>
                                                                <td>
                                                                    <span className="algorithm-badge badge-ai">
                                                                        {algorithmInfo[selectedAlgorithm]?.name}
                                                                    </span>
                                                                </td>
                                                            </tr>
                                                        );
                                                    })}
                                                </tbody>
                                            </table>
                                        </div>
                                    )}
                                </div>

                                {/* ÌååÎùºÎ©îÌÑ∞ ÌòÑÌô© Î∞è ÌäúÎãù Í∞ÄÏù¥Îìú */}
                                <div className="card" style={{background: 'linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%)'}}>
                                    <div className="card-header">
                                        <i className="fas fa-cogs text-blue-600"></i>
                                        <h2 className="card-title">üéõÔ∏è ÌååÎùºÎ©îÌÑ∞ ÌäúÎãù Í∞ÄÏù¥Îìú</h2>
                                    </div>
                                    
                                    <div className="grid" style={{gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))'}}>
                                        <div>
                                            <h4 className="font-bold text-blue-700 mb-2">üéØ ÌòÑÏû¨ ÏÑ§Ï†ï</h4>
                                            <div className="bg-white p-3 rounded-lg text-xs">
                                                <strong>Î™®Îç∏:</strong> {algorithmInfo[selectedAlgorithm]?.name}<br/>
                                                <strong>ÌååÎùºÎ©îÌÑ∞:</strong><br/>
                                                {Object.entries(algorithmParameters[selectedAlgorithm]).map(([key, value]) => (
                                                    <div key={key} className="ml-2">
                                                        ‚Ä¢ {key}: <span className="text-blue-600 font-mono">{value}</span>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                        
                                        <div>
                                            <h4 className="font-bold text-purple-700 mb-2">üí° ÌäúÎãù ÌåÅ</h4>
                                            <ul className="text-sm text-purple-600 space-y-1">
                                                <li>‚Ä¢ Í≥ºÏ†ÅÌï© Î∞úÏÉùÏãú ‚Üí Î≥µÏû°ÎèÑ Í¥ÄÎ†® ÌååÎùºÎ©îÌÑ∞ Í∞êÏÜå</li>
                                                <li>‚Ä¢ Í≥ºÏÜåÏ†ÅÌï© Î∞úÏÉùÏãú ‚Üí Î™®Îç∏ Ïö©Îüâ Í¥ÄÎ†® ÌååÎùºÎ©îÌÑ∞ Ï¶ùÍ∞Ä</li>
                                                <li>‚Ä¢ Î∂àÏïàÏ†ïÌïú ÏòàÏ∏°Ïãú ‚Üí ÌïôÏäµÎ•†/Í∞ÄÏ§ëÏπò Ï°∞Ï†ï</li>
                                                <li>‚Ä¢ Í≥ÑÏ†àÏÑ± ÎØ∏Î∞òÏòÅÏãú ‚Üí Í≥ÑÏ†àÏÑ± Í¥ÄÎ†® ÌååÎùºÎ©îÌÑ∞ Ï¶ùÍ∞Ä</li>
                                            </ul>
                                        </div>
                                    </div>
                                    
                                    <div className="mt-4 p-4 bg-white rounded-lg border-l-4 border-green-500">
                                        <h4 className="font-bold text-gray-800 mb-2">üìã CSV ÌååÏùº ÌòïÏãù ÏòàÏãú</h4>
                                        <div className="bg-gray-100 rounded p-3 text-xs font-mono">
                                            year,month,country,product,sales<br/>
                                            2019,1,ÌïúÍµ≠,Ï†úÌíàA,150<br/>
                                            2019,1,ÌïúÍµ≠,Ï†úÌíàB,120<br/>
                                            2019,1,ÎØ∏Íµ≠,Ï†úÌíàA,280<br/>
                                            2020,1,ÌïúÍµ≠,Ï†úÌíàA,165<br/>
                                            ...
                                        </div>
                                        <p className="text-xs text-gray-600 mt-2">
                                            <strong>ÌïÑÏàò Ïª¨Îüº:</strong> year(Ïó∞ÎèÑ), month(Ïõî), sales(Îß§Ï∂ú)<br/>
                                            <strong>ÏÑ†ÌÉù Ïª¨Îüº:</strong> country(Íµ≠Í∞Ä), product(Ï†úÌíà)
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Ïï± Î†åÎçîÎßÅ
        ReactDOM.render(<AdvancedSalesForecastingApp />, document.getElementById('root'));
    </script>
</body>
</html>
