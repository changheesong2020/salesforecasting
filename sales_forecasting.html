<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sales Forecasting</title>
  <link rel="stylesheet" href="sales_forecasting.css">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="light-mode">
  <button id="theme-toggle" class="theme-toggle">ğŸŒ™</button>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    // í…Œë§ˆ í† ê¸€
    const toggleButton = document.getElementById('theme-toggle');
    toggleButton.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      document.body.classList.toggle('light-mode');
      toggleButton.textContent = document.body.classList.contains('dark-mode') ? 'â˜€ï¸' : 'ğŸŒ™';
    });

    // ì•Œê³ ë¦¬ì¦˜ ì •ë³´ (dark_sales_forecaster ì°¸ê³ )
    const algorithmInfo = {
      baseline: {
        name: "Baseline",
        description: "ë§ˆì§€ë§‰ ì‹¤ì œ ê°’ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ëŠ” ê¸°ë³¸ ì˜ˆì¸¡ì…ë‹ˆë‹¤."
      },
      advanced_ensemble: {
        name: "ê³ ê¸‰ ì•™ìƒë¸”",
        description: "4ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ ì˜ˆì¸¡ ëª¨ë¸ì„ ìµœì  ê°€ì¤‘ì¹˜ë¡œ ê²°í•©í•˜ì—¬ ë”ìš± ì •í™•í•˜ê³  ì•ˆì •ì ì¸ ì˜ˆì¸¡ì„ ì œê³µí•©ë‹ˆë‹¤."
      }
    };

    // ì•Œê³ ë¦¬ì¦˜ íŒŒë¼ë¯¸í„° ê¸°ë³¸ê°’
    const algorithmParameters = {
      baseline: { forecast_length: 12 },
      advanced_ensemble: { trend_weight: 0.25, seasonal_weight: 0.25, ma_weight: 0.25, exp_weight: 0.25, forecast_length: 12 }
    };

    // ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ (dark_sales_forecaster ì°¸ê³ )
    const algorithms = {
      baseline: (data, params) => {
        if (data.length === 0) return [];
        const last = data[data.length - 1].sales;
        const predictions = [];
        for (let i = 1; i <= params.forecast_length; i++) {
          predictions.push({ year: 2025, month: i, sales: Math.round(Math.max(0, last)) });
        }
        return predictions;
      },
      advanced_ensemble: (data, params) => {
        if (data.length === 0) return [];
        const predictions = [];
        for (let i = 1; i <= params.forecast_length; i++) {
          const recent = data.slice(-6).reduce((s, d) => s + d.sales, 0) / 6;
          const seasonal = 1 + 0.15 * Math.sin((i - 1) / 12 * 2 * Math.PI);
          const predicted = recent * (1 + 0.05) * seasonal;
          predictions.push({ year: 2025, month: i, sales: Math.round(Math.max(0, predicted)) });
        }
        return predictions;
      }
    };

    const aggregateData = (rows) => {
      const grouped = {};
      rows.forEach(d => {
        const key = `${d.year}-${d.month}`;
        if (!grouped[key]) grouped[key] = { year: d.year, month: d.month, sales: 0 };
        grouped[key].sales += d.sales;
      });
      return Object.values(grouped).sort((a,b) => a.year - b.year || a.month - b.month);
    };

    const App = () => {
      const [data, setData] = useState([]);
      const [selectedAlgorithm, setSelectedAlgorithm] = useState('baseline');
      const [showConfidenceInterval, setShowConfidenceInterval] = useState(true);
      const aggregated = useMemo(() => aggregateData(data), [data]);
      const predictions = useMemo(() => algorithms[selectedAlgorithm](aggregated, algorithmParameters[selectedAlgorithm]), [aggregated, selectedAlgorithm]);

      useEffect(() => {
        fetch('filtered_total_sheet_data.csv')
          .then(res => res.text())
          .then(text => {
            const rows = text.trim().split('\n').slice(1).map(line => {
              const [year, month, sales] = line.split(',');
              return { year: parseInt(year), month: parseInt(month), sales: parseFloat(sales) };
            });
            setData(rows);
          });
      }, []);

      return (
        <div className="container">
          <div className="card">
            <label>ëª¨ë¸ ì„ íƒ: </label>
            <select value={selectedAlgorithm} onChange={e => setSelectedAlgorithm(e.target.value)}>
              {Object.entries(algorithmInfo).map(([key, info]) => (
                <option key={key} value={key}>{info.name}</option>
              ))}
            </select>
          </div>

          <div className="card">
            <h2>2025ë…„ ì›”ë³„ ì˜ˆì¸¡</h2>
            <div className="table-container">
              <table className="table">
                <thead>
                  <tr>
                    <th>ì›”</th>
                    <th className="text-right">ì˜ˆì¸¡ ë§¤ì¶œ (ë§Œì›)</th>
                    <th className="text-right">ì „ë…„ ë™ì›” ëŒ€ë¹„</th>
                    <th className="text-right">ì‹ ë¢°êµ¬ê°„</th>
                    <th>ëª¨ë¸</th>
                  </tr>
                </thead>
                <tbody>
                  {predictions.map((pred, idx) => {
                    const lastYear = aggregated.find(d => d.year === 2024 && d.month === pred.month)?.sales || 0;
                    const growth = lastYear ? ((pred.sales - lastYear) / lastYear * 100).toFixed(1) : '0.0';
                    return (
                      <tr key={idx}>
                        <td>{pred.month}ì›”</td>
                        <td className="text-right">{pred.sales.toLocaleString()}</td>
                        <td className={growth >= 0 ? 'text-right text-green' : 'text-right text-red'}>{growth}%</td>
                        <td className="text-right">{showConfidenceInterval ? `Â±${(pred.sales * 0.15).toFixed(0)}` : 'N/A'}</td>
                        <td>{algorithmInfo[selectedAlgorithm]?.name}</td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
